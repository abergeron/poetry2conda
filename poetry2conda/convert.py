import argparse
from datetime import datetime

import semantic_version
import toml

from poetry2conda import __version__


def convert(file):
    poetry2conda_config, poetry_config = parse_pyproject_toml(file)
    env_name = poetry2conda_config['name']
    poetry_dependencies = poetry_config.get('dependencies', {})
    conda_constraints = poetry2conda_config.get('dependencies', {})

    dependencies, pip_dependencies = collect_dependencies(poetry_dependencies, conda_constraints)
    conda_yaml = to_yaml_string(env_name, dependencies, pip_dependencies)
    return conda_yaml


def convert_version(spec_str):
    spec = semantic_version.SimpleSpec.parse(spec_str)
    if isinstance(spec.clause, semantic_version.base.AllOf):
        converted = ','.join(sorted(map(str, spec.clause.clauses), reverse=True))
    else:
        converted = str(spec.clause)
    return converted


def parse_pyproject_toml(file):
    pyproject_toml = toml.loads(file.read())
    poetry_config = pyproject_toml.get('tool', {}).get('poetry', {})
    if not poetry_config:
        raise RuntimeError(f'tool.poetry section was not found on {file.name}')

    poetry2conda_config = pyproject_toml.get('tool', {}).get('poetry2conda', {})
    if not poetry2conda_config:
        raise RuntimeError(f'tool.poetry2conda section was not found on {file.name}')

    if 'name' not in poetry2conda_config or not isinstance(poetry2conda_config['name'], str):
        raise RuntimeError(f'tool.poetry2conda.name entry was not found on {file.name}')

    return poetry2conda_config, poetry_config


def collect_dependencies(poetry_dependencies, conda_constraints):
    dependencies = {}
    pip_dependencies = {}
    for name, constraint in poetry_dependencies.items():
        if isinstance(constraint, str):
            dependencies[name] = convert_version(constraint)
        elif isinstance(constraint, dict):
            if 'git' in constraint:
                git = constraint['git']
                tag = constraint['tag']
                pip_dependencies[f'git+{git}@{tag}#egg={name}'] = None
            else:
                raise ValueError(f'This converter only supports normal dependencies and '
                                 f'git dependencies. No path, url, python restricted, '
                                 f'environment markers or multiple constraints. In your '
                                 f'case, check the "{name}" dependency. Sorry.')
        else:
            raise ValueError(f'This converter only supports normal dependencies and '
                             f'git dependencies. No multiple constraints. In your '
                             f'case, check the "{name}" dependency. Sorry.')

        if name in conda_constraints:
            conda_dict = conda_constraints[name]
            if 'name' in conda_dict:
                new_name = conda_dict['name']
                dependencies[new_name] = dependencies.pop(name)
                name = new_name
            # do channel last, because it may move from dependencies to pip_dependencies
            if 'channel' in conda_dict:
                channel = conda_dict['channel']
                if channel == 'pip':
                    pip_dependencies[name] = dependencies.pop(name)
                else:
                    new_name = f'{channel}::{name}'
                    dependencies[new_name] = dependencies.pop(name)

    if pip_dependencies:
        dependencies['pip'] = None

    return dependencies, pip_dependencies


def to_yaml_string(env_name, dependencies, pip_dependencies):
    deps_str = []
    for name, version in dependencies.items():
        version = version or ''
        deps_str.append(f'  - {name}{version}')
    if pip_dependencies:
        deps_str.append(f'  - pip:')
    for name, version in pip_dependencies.items():
        version = version or ''
        deps_str.append(f'    - {name}{version}')
    deps_str = '\n'.join(deps_str)

    date_str = datetime.now().strftime('%c')
    conda_yaml = f"""
###############################################################################
# NOTE: This file has been auto-generated by poetry2conda
#       poetry2conda version = {__version__} 
#       date: {date_str}
###############################################################################
# If you want to change the contents of this file, you should probably change
# the pyproject.toml file and then use poetry2conda again to update this file.
# Alternatively, stop using (ana)conda.
###############################################################################
name: {env_name}
dependencies:
{deps_str}
""".lstrip()
    return conda_yaml


def main():
    parser = argparse.ArgumentParser(description='Convert a poetry-based pyproject.toml '
                                                 'to a conda environment.yaml')
    parser.add_argument('pyproject', metavar='TOML', type=argparse.FileType('r'),
                        help='pyproject.toml input file.')
    parser.add_argument('environment', metavar='YAML', type=argparse.FileType('w'),
                        help='environment.yaml output file.')
    parser.add_argument('--version', action='version', version=f'%(prog)s (version {__version__})')
    args = parser.parse_args()
    args.environment.write(convert(args.pyproject))


if __name__ == '__main__':
    main()
